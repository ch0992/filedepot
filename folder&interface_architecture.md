# 폴더 및 인터페이스 아키텍처 설계 문서

## 1. app/{service} 구조를 사용하는 이유
- 각 마이크로서비스를 `app/services/{service}` 하위에 배치하여, 서비스별 코드의 독립성과 명확한 경계를 유지합니다.
- 서비스별로 main.py, api/, schemas/, services/, tests/, config.py 등 표준 구조를 따르므로, 신규 서비스 추가 및 확장이 용이합니다.

## 2. services/interfaces/와 impl/ 구조로 분리한 이유
- `interfaces/`에는 서비스의 역할(계약, 인터페이스)만 정의하고, 실제 구현은 `impl/`에 둡니다.
- 이로 인해 서비스 구현을 쉽게 교체(예: Mock, DB, 외부 API 등)할 수 있고, 테스트와 유지보수성이 크게 향상됩니다.

## 3. Protocol 기반 인터페이스의 장점
- Python의 typing.Protocol을 활용해 의존성 주입(Dependency Injection)이 가능하며, 런타임에 duck-typing으로 대체 구현체를 쉽게 주입할 수 있습니다.
- 테스트 시 mock 객체로 교체가 쉽고, 실제 서비스 구현체를 교체할 때도 코드 변경이 최소화됩니다.
- 확장성: 새로운 구현체(예: MinIO→S3, PostgreSQL→MySQL) 추가 시 인터페이스만 맞추면 됨

## 4. core/, db/, dependencies/가 app/ 하위에 위치하는 이유
- 모든 서비스에서 공통적으로 사용하는 환경설정, DB, 의존성 주입 모듈은 app/ 하위에 위치시켜 재사용성과 일관성을 높입니다.
- 서비스별로 중복 구현을 방지하고, 공통 로직을 한 곳에서 관리할 수 있습니다.

## 5. 전체 구조의 확장성과 유지보수성
- 서비스별 독립적 구조와 공통 모듈의 분리로, 대규모 서비스 확장/변경/테스트가 용이합니다.
- 인터페이스 기반 설계로 실제 서비스 구현체 교체, 테스트 환경 전환, 신규 기능 추가가 쉽습니다.
- 인프라/배포/운영과 코드가 명확히 분리되어 DevOps 및 팀 협업에 유리합니다.
